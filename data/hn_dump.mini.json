[
  {
    "created_at": "2012-06-29T14:58:09.000Z",
    "title": "",
    "url": "",
    "author": "reitzensteinm",
    "points": 54,
    "story_text": null,
    "comment_text": "The top answer has it exactly right. This should be Root Cause, since ultimately even bugs caused by human errors are really caused by systemic flaws. Some examples:<p><pre><code>  * SQLite has 1177 times as many tests as code (not a typo)\n  * Live television is broadcast with a 5-10 second delay\n  * IMVU automatically reverts commits pushed to the site if regressions are detected\n  * Netflix implemented a system called the Chaos Monkey, which randomly shuts \n    down processes. Ensures the system can survive any failure\n  * VLC, Unity3D, Windows, 3D Studio Max and many more applications phone\n    home crashes, which allows developers to quickly patch frequent issues\n  * Code reviews and pair programming ensure no one person's mistake\n    can break critical code sections\n  * Similarly, multiple people should sign off on copy written. For newsletters\n    and press releases the whole team should, since they can't be withdrawn\n  * Well designed systems automatically backup, and those backups are \n    automatically tested, so nothing is deleted forever\n</code></pre>\nChange \"who\" to \"why\" and a horrible idea turns into a brilliant one. Well designed systems can reduce the risk of almost any mistake, at the cost of speed and flexibility.<p>Ultimately it's up to the company to decide where the balance lies, and to live with the consequences. Startups will accept a drastically different risk profile to banks and Fortune 500 companies.",
    "num_comments": null,
    "story_id": 4176658,
    "story_title": "My boss decided to add a person to blame field to every bug report",
    "story_url": "http://programmers.stackexchange.com/questions/154733/my-boss-decided-to-add-a-person-to-blame-field-to-every-bug-report-how-can-i",
    "parent_id": 4176658,
    "created_at_i": 1340981889,
    "relevancy_score": 4005,
    "_tags": [
      "comment",
      "author_reitzensteinm",
      "story_4176658"
    ],
    "objectID": "4176905",
    "_highlightResult": {
      "title": {
        "value": "",
        "matchLevel": "none",
        "matchedWords": []
      },
      "url": {
        "value": "",
        "matchLevel": "none",
        "matchedWords": []
      },
      "author": {
        "value": "reitzensteinm",
        "matchLevel": "none",
        "matchedWords": []
      },
      "comment_text": {
        "value": "The top answer has it exactly right. This should be Root Cause, since ultimately even bugs caused by human errors are really caused by systemic flaws. Some examples:<p><pre><code>  * <em>SQLite</em> has 1177 times as many tests as code (not a typo)\n  * Live television is broadcast with a 5-10 second delay\n  * IMVU automatically reverts commits pushed to the site if regressions are detected\n  * Netflix implemented a system called the Chaos Monkey, which randomly shuts \n    down processes. Ensures the system can survive any failure\n  * VLC, Unity3D, Windows, 3D Studio Max and many more applications phone\n    home crashes, which allows developers to quickly patch frequent issues\n  * Code reviews and pair programming ensure no one person's mistake\n    can break critical code sections\n  * Similarly, multiple people should sign off on copy written. For newsletters\n    and press releases the whole team should, since they can't be withdrawn\n  * Well designed systems automatically backup, and those backups are \n    automatically tested, so nothing is deleted forever\n</code></pre>\nChange \"who\" to \"why\" and a horrible idea turns into a brilliant one. Well designed systems can reduce the risk of almost any mistake, at the cost of speed and flexibility.<p>Ultimately it's up to the company to decide where the balance lies, and to live with the consequences. Startups will accept a drastically different risk profile to banks and Fortune 500 companies.",
        "matchLevel": "full",
        "fullyHighlighted": false,
        "matchedWords": [
          "sqlite"
        ]
      },
      "story_title": {
        "value": "My boss decided to add a person to blame field to every bug report",
        "matchLevel": "none",
        "matchedWords": []
      },
      "story_url": {
        "value": "http://programmers.stackexchange.com/questions/154733/my-boss-decided-to-add-a-person-to-blame-field-to-every-bug-report-how-can-i",
        "matchLevel": "none",
        "matchedWords": []
      }
    }
  },
  {
    "created_at": "2011-06-15T18:34:46.000Z",
    "title": "",
    "url": "",
    "author": "DavidMcLaughlin",
    "points": 52,
    "story_text": null,
    "comment_text": "This seems incredibly naive.<p>ORMs reduce code duplication. They speed up development, especially when you're treating the underlying data storage as a \"dumb\" datastore that could just as easily be sqlite or H2 as MySQL or Postgres.<p>As for ORMs having some sort of negative impact on the queries sent to the underlying database - it really depends on what ORM you use but any ORM I've used had support for pre-loading relationships in advance when required, removing that N+1 problem.<p>I also want to add that I wrote an ORM for the first company I worked for and when it was finished it was a drop-in replacement for 90% of the queries in our application - and I mean that literally the SQL generated by the ORM was exactly the same as the SQL being replaced. The queries that it couldn't replace (mainly reporting queries) <i>already had an aggressively tuned caching layer in front of them anyway because they were so hairy</i>.<p>But the real point is this: the performance of the ORM didn't really matter because we were a database driven website that needed to scale - so we had layers upon layers of caching to deal with that issue.<p>And that is an extremely important point - the way ORMs generalise a lot of queries (every query for an object is always the same no matter what columns you really need) lends itself to extremely good cache performance. Take the query cache of MySQL for example - it stores result sets in a sort of LRU. If you make n queries for the same row in a DB but select different columns each time - you store the same \"entity\" n times in the query cache. Depending on how big n is, that can cause much worse cache hit performance than simply storing one representation of that entity and letting all n use cases use the attributes they need.<p>Now, relying on MySQL's query cache for anything would not be smart, but replace it with memcached or reddis or whatever memory-is-a-premium cache and the same point stands. \nAnother example to drive the point home is a result set where you join the result entities to the user query so that you can get all the results back in a single query. In theory this is a great way to reduce the number of queries sent to your DB but if you have caching then there are many times where you could have very low cache hit ratios for user queries since they tend to be unique (for example they use user id) but where you could still get great cache hit performance if certain entities appear often across all those result sets by leaving out the join and doing N+1 fetches instead.<p>ORMs prevent you from scaling as much as using Python or Ruby over C does.<p>So I guess that leaves the point about leaky or broken abstractions. Well I would never claim that you can abstract across a whole bunch of databases anyway, I think that's a ridiculous claim that most ORMs make. These types of abstractions when people try to hide the underlying technology are really just a lowest-common-denominator of all the feature sets. So if you chose some technology because you really wanted a differentiating feature then most likely you will find yourself working against such abstractions. Interestingly enough, the dire support for cross-database queries which are perfectly legal in MySQL but not in other vendors is the reason I had to roll my own ORM. But the productivity and maintainability benefits were well worth it.<p>So yeah I guess what I'm saying is: premature optimization is the root of all evil, there are no silver bullets and performance and scalability is about measuring and optimising where needed. And finally: ORMs are not an anti-pattern.",
    "num_comments": null,
    "story_id": 2657745,
    "story_title": "ORM is an anti-pattern",
    "story_url": "http://seldo.com/weblog/2011/06/15/orm_is_an_antipattern",
    "parent_id": 2657745,
    "created_at_i": 1308162886,
    "relevancy_score": 3279,
    "_tags": [
      "comment",
      "author_DavidMcLaughlin",
      "story_2657745"
    ],
    "objectID": "2658443",
    "_highlightResult": {
      "title": {
        "value": "",
        "matchLevel": "none",
        "matchedWords": []
      },
      "url": {
        "value": "",
        "matchLevel": "none",
        "matchedWords": []
      },
      "author": {
        "value": "DavidMcLaughlin",
        "matchLevel": "none",
        "matchedWords": []
      },
      "comment_text": {
        "value": "This seems incredibly naive.<p>ORMs reduce code duplication. They speed up development, especially when you're treating the underlying data storage as a \"dumb\" datastore that could just as easily be <em>sqlite</em> or H2 as MySQL or Postgres.<p>As for ORMs having some sort of negative impact on the queries sent to the underlying database - it really depends on what ORM you use but any ORM I've used had support for pre-loading relationships in advance when required, removing that N+1 problem.<p>I also want to add that I wrote an ORM for the first company I worked for and when it was finished it was a drop-in replacement for 90% of the queries in our application - and I mean that literally the SQL generated by the ORM was exactly the same as the SQL being replaced. The queries that it couldn't replace (mainly reporting queries) <i>already had an aggressively tuned caching layer in front of them anyway because they were so hairy</i>.<p>But the real point is this: the performance of the ORM didn't really matter because we were a database driven website that needed to scale - so we had layers upon layers of caching to deal with that issue.<p>And that is an extremely important point - the way ORMs generalise a lot of queries (every query for an object is always the same no matter what columns you really need) lends itself to extremely good cache performance. Take the query cache of MySQL for example - it stores result sets in a sort of LRU. If you make n queries for the same row in a DB but select different columns each time - you store the same \"entity\" n times in the query cache. Depending on how big n is, that can cause much worse cache hit performance than simply storing one representation of that entity and letting all n use cases use the attributes they need.<p>Now, relying on MySQL's query cache for anything would not be smart, but replace it with memcached or reddis or whatever memory-is-a-premium cache and the same point stands. \nAnother example to drive the point home is a result set where you join the result entities to the user query so that you can get all the results back in a single query. In theory this is a great way to reduce the number of queries sent to your DB but if you have caching then there are many times where you could have very low cache hit ratios for user queries since they tend to be unique (for example they use user id) but where you could still get great cache hit performance if certain entities appear often across all those result sets by leaving out the join and doing N+1 fetches instead.<p>ORMs prevent you from scaling as much as using Python or Ruby over C does.<p>So I guess that leaves the point about leaky or broken abstractions. Well I would never claim that you can abstract across a whole bunch of databases anyway, I think that's a ridiculous claim that most ORMs make. These types of abstractions when people try to hide the underlying technology are really just a lowest-common-denominator of all the feature sets. So if you chose some technology because you really wanted a differentiating feature then most likely you will find yourself working against such abstractions. Interestingly enough, the dire support for cross-database queries which are perfectly legal in MySQL but not in other vendors is the reason I had to roll my own ORM. But the productivity and maintainability benefits were well worth it.<p>So yeah I guess what I'm saying is: premature optimization is the root of all evil, there are no silver bullets and performance and scalability is about measuring and optimising where needed. And finally: ORMs are not an anti-pattern.",
        "matchLevel": "full",
        "fullyHighlighted": false,
        "matchedWords": [
          "sqlite"
        ]
      },
      "story_title": {
        "value": "ORM is an anti-pattern",
        "matchLevel": "none",
        "matchedWords": []
      },
      "story_url": {
        "value": "http://seldo.com/weblog/2011/06/15/orm_is_an_antipattern",
        "matchLevel": "none",
        "matchedWords": []
      }
    }
  },
  {
    "created_at": "2013-11-28T18:43:33.000Z",
    "title": null,
    "url": null,
    "author": "kkowalczyk",
    "points": 49,
    "story_text": null,
    "comment_text": "1. 3.8.0.2 fixed a logical error in the code. High-level language won&#x27;t help you if you invert a logical condition or commit some more subtle logical mistake.<p>2. Our software also needs to be fast. No one needs a slow database engine. There is no high-level language that beats C on tasks like writing sqlite.<p>3. Finally, show me that unicorn high-level language with strong, automatically provable invariants and one piece of widely used, reliable software that was written in it.<p>Sqlite works. Testing works.<p>If there actually was a credible alternative to C for writing software that is efficient and reliable with requirements that sqlite has, I can assure you that people would use it. The problem is: it doesn&#x27;t exist.",
    "num_comments": null,
    "story_id": 6815321,
    "story_title": "How SQLite is tested",
    "story_url": "http://www.sqlite.org/testing.html",
    "parent_id": 6815638,
    "created_at_i": 1385664213,
    "relevancy_score": 5000,
    "_tags": [
      "comment",
      "author_kkowalczyk",
      "story_6815321"
    ],
    "objectID": "6815853",
    "_highlightResult": {
      "author": {
        "value": "kkowalczyk",
        "matchLevel": "none",
        "matchedWords": []
      },
      "comment_text": {
        "value": "1. 3.8.0.2 fixed a logical error in the code. High-level language won't help you if you invert a logical condition or commit some more subtle logical mistake.<p>2. Our software also needs to be fast. No one needs a slow database engine. There is no high-level language that beats C on tasks like writing <em>sqlite</em>.<p>3. Finally, show me that unicorn high-level language with strong, automatically provable invariants and one piece of widely used, reliable software that was written in it.<p><em>Sqlite</em> works. Testing works.<p>If there actually was a credible alternative to C for writing software that is efficient and reliable with requirements that <em>sqlite</em> has, I can assure you that people would use it. The problem is: it doesn't exist.",
        "matchLevel": "full",
        "fullyHighlighted": false,
        "matchedWords": [
          "sqlite"
        ]
      },
      "story_title": {
        "value": "How <em>SQLite</em> is tested",
        "matchLevel": "full",
        "fullyHighlighted": false,
        "matchedWords": [
          "sqlite"
        ]
      },
      "story_url": {
        "value": "http://www.<em>sqlite</em>.org/testing.html",
        "matchLevel": "full",
        "fullyHighlighted": false,
        "matchedWords": [
          "sqlite"
        ]
      }
    }
  },
  {
    "created_at": "2014-03-19T10:35:07.000Z",
    "title": null,
    "url": null,
    "author": "selmnoo",
    "points": 48,
    "story_text": null,
    "comment_text": "I don&#x27;t get it. This guy&#x27;s resume says he&#x27;s a double major of math&#x2F;CS from Berkeley with high honors -- and apparently he&#x27;s worked on pretty hardcore engineering projects.<p><pre><code>    I&#x27;ve created a Linux distro of my own. Original and not a fork. \\n    See articles on website. Geared towards CLI engineers.\\n    Patched and built about 1,800 packages myself. Supported \\n    and customized standard distros as well.\\n    Double Bachelors in Math and Computer Science from U.C. Berkeley. \\n    High Honors and Honors. Worked with Open Source\\n    since the 1980s. Led small teams in startup and similar environments.\\n    Considered to be good at writing and analysis of problems.\\n    Experience includes: Agile, Assembly, Back-End, BSD, C, CSS, Debian,\\n    FOSS, GIMP, HTTP, Java, Linux, Mathematics, Mint,\\n    MySQL, Octave (similar to Matlab), Open Source, Parser, Perl, PHP5,\\n    Python, Recruiting, Regex, Shell, SQLite3, Support,\\n    TCP&#x2F;IP, Ubuntu, UNIX, Tcl&#x2F;Tk, Teaching, Training, Transcoding, \\n    VPS, Writing, XML, XSLT\\n</code></pre>\\nWhat is wrong with Silicon Valley today that a person like him can&#x27;t get a reliable job, and therefore is unable to live with medical healthcare, a reasonable place of residence, etc.?<p>edit: on the bright side, now that this post is on HN frontpage, I hope someone seeks this guy out and gives him a job. From what I can grasp, the quality of his code is pretty damn good.",
    "num_comments": null,
    "story_id": 7427542,
    "story_title": "What Happens to Older Developers?",
    "story_url": "http://christfollower.me/D140313ADVICE",
    "parent_id": 7427542,
    "created_at_i": 1395225307,
    "relevancy_score": 5215,
    "_tags": [
      "comment",
      "author_selmnoo",
      "story_7427542"
    ],
    "objectID": "7427712",
    "_highlightResult": {
      "author": {
        "value": "selmnoo",
        "matchLevel": "none",
        "matchedWords": []
      },
      "comment_text": {
        "value": "I don't get it. This guy's resume says he's a double major of math/CS from Berkeley with high honors -- and apparently he's worked on pretty hardcore engineering projects.<p><pre><code>    I've created a Linux distro of my own. Original and not a fork. \\n    See articles on website. Geared towards CLI engineers.\\n    Patched and built about 1,800 packages myself. Supported \\n    and customized standard distros as well.\\n    Double Bachelors in Math and Computer Science from U.C. Berkeley. \\n    High Honors and Honors. Worked with Open Source\\n    since the 1980s. Led small teams in startup and similar environments.\\n    Considered to be good at writing and analysis of problems.\\n    Experience includes: Agile, Assembly, Back-End, BSD, C, CSS, Debian,\\n    FOSS, GIMP, HTTP, Java, Linux, Mathematics, Mint,\\n    MySQL, Octave (similar to Matlab), Open Source, Parser, Perl, PHP5,\\n    Python, Recruiting, Regex, Shell, <em>SQLite</em>3, Support,\\n    TCP/IP, Ubuntu, UNIX, Tcl/Tk, Teaching, Training, Transcoding, \\n    VPS, Writing, XML, XSLT\\n</code></pre>\\nWhat is wrong with Silicon Valley today that a person like him can't get a reliable job, and therefore is unable to live with medical healthcare, a reasonable place of residence, etc.?<p>edit: on the bright side, now that this post is on HN frontpage, I hope someone seeks this guy out and gives him a job. From what I can grasp, the quality of his code is pretty damn good.",
        "matchLevel": "full",
        "fullyHighlighted": false,
        "matchedWords": [
          "sqlite"
        ]
      },
      "story_title": {
        "value": "What Happens to Older Developers?",
        "matchLevel": "none",
        "matchedWords": []
      },
      "story_url": {
        "value": "http://christfollower.me/D140313ADVICE",
        "matchLevel": "none",
        "matchedWords": []
      }
    }
  },
  {
    "created_at": "2013-06-16T01:44:26.000Z",
    "title": "",
    "url": "",
    "author": "rogerbinns",
    "points": 45,
    "story_text": null,
    "comment_text": "I am very familiar with SQLite internals.  The answer is already in there.  SQLite stores each row as each column value encoded sequentially corresponding to the declared order of the columns.  Changing column order or deletions&#x2F;inserts require a rewrite of every row.  The one special case that is allowed is adding a column on the end of the schema providing it has a default value.<p>A SQLite provided ALTER TABLE implementation would do exactly what was stated - start a transaction, rename the existing table to a temporary name, create a new one with the desired schema, and copy data across mangling as appropriate before deleting the old table and finishing the transaction.  For plain tables this is no big deal, but for more complicated ones there are a lot of issues such as foreign key references, constraints, indices.  The majority of the code would be dealing with all these conditions and interactions.<p>It also wouldn&#x27;t be any more efficient than code the developer writes - ie there are no shortcuts available to the SQLite developers that aren&#x27;t available to developers using SQLite.  The net effect would be a larger library (they limit to a 250kb library size so something else would need to be chopped), some complex documentation and a heck of a lot of testing code.  For something that is relatively rarely needed (see requests on the mailing lists).<p>The chance of something like this ending up in the SQLite core is extremely slim, so you could never depend on it being there anyway.<p>SQLite does have several things to help.  There is a user_version pragma you can use to keep track of the schema version and use for upgrading.  You can temporarily disable foreign key and constraint enforcing.  There are numerous pragmas to get table metadata.  The table definitions are stored as SQL strings in a sqlite master table, and a pragma allows you to make that writeable.",
    "num_comments": null,
    "story_id": 5886898,
    "story_title": "The lack of proper alter table support in SQLite",
    "story_url": "http://dustycloud.org/blog/sqlite-alter-pain/",
    "parent_id": 5886898,
    "created_at_i": 1371347066,
    "relevancy_score": 4677,
    "_tags": [
      "comment",
      "author_rogerbinns",
      "story_5886898"
    ],
    "objectID": "5887053",
    "_highlightResult": {
      "title": {
        "value": "",
        "matchLevel": "none",
        "matchedWords": []
      },
      "url": {
        "value": "",
        "matchLevel": "none",
        "matchedWords": []
      },
      "author": {
        "value": "rogerbinns",
        "matchLevel": "none",
        "matchedWords": []
      },
      "comment_text": {
        "value": "I am very familiar with <em>SQLite</em> internals.  The answer is already in there.  <em>SQLite</em> stores each row as each column value encoded sequentially corresponding to the declared order of the columns.  Changing column order or deletions/inserts require a rewrite of every row.  The one special case that is allowed is adding a column on the end of the schema providing it has a default value.<p>A <em>SQLite</em> provided ALTER TABLE implementation would do exactly what was stated - start a transaction, rename the existing table to a temporary name, create a new one with the desired schema, and copy data across mangling as appropriate before deleting the old table and finishing the transaction.  For plain tables this is no big deal, but for more complicated ones there are a lot of issues such as foreign key references, constraints, indices.  The majority of the code would be dealing with all these conditions and interactions.<p>It also wouldn't be any more efficient than code the developer writes - ie there are no shortcuts available to the <em>SQLite</em> developers that aren't available to developers using <em>SQLite</em>.  The net effect would be a larger library (they limit to a 250kb library size so something else would need to be chopped), some complex documentation and a heck of a lot of testing code.  For something that is relatively rarely needed (see requests on the mailing lists).<p>The chance of something like this ending up in the <em>SQLite</em> core is extremely slim, so you could never depend on it being there anyway.<p><em>SQLite</em> does have several things to help.  There is a user_version pragma you can use to keep track of the schema version and use for upgrading.  You can temporarily disable foreign key and constraint enforcing.  There are numerous pragmas to get table metadata.  The table definitions are stored as SQL strings in a <em>sqlite</em> master table, and a pragma allows you to make that writeable.",
        "matchLevel": "full",
        "fullyHighlighted": false,
        "matchedWords": [
          "sqlite"
        ]
      },
      "story_title": {
        "value": "The lack of proper alter table support in <em>SQLite</em>",
        "matchLevel": "full",
        "fullyHighlighted": false,
        "matchedWords": [
          "sqlite"
        ]
      },
      "story_url": {
        "value": "http://dustycloud.org/blog/<em>sqlite</em>-alter-pain/",
        "matchLevel": "full",
        "fullyHighlighted": false,
        "matchedWords": [
          "sqlite"
        ]
      }
    }
  }
]
